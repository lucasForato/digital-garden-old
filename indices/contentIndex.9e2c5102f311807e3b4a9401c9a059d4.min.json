{"/":{"title":"Home","content":"\n# Home\n\nWelcome to my digital garden!\n\nThis blog is a living collection of my thoughts, ideas, and notes, carefully nurtured and cultivated in a digital space. Here, you'll find a diverse range of topics, each representing a unique seed of knowledge waiting to blossom.\n\nI encourage you to engage with me by leaving messages, sharing your thoughts, or asking questions. This digital garden thrives on collaboration and the exchange of ideas.\n\nWelcome once again, and happy exploring!\n\n## Topics\n\n[[notes/Architecture Patterns|Architecture Patterns]]\n\n[[notes/Computer Networks|Computer Networks]]\n\n[[notes/AWS|AWS]]","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/AWS":{"title":"AWS","content":"\n# What is it?\n\nAmazon Web Services (AWS) is the world’s most comprehensive and broadly adopted cloud, offering over 200 fully featured services\n\n# Services\n\n[[Elastic Container Service (ECS)]]\n\n[[Elastic Compute Cloud (EC2)]]\n\n[[Elastic Load Balancer (ELB)]]\n\n[[AWS S3]]\n\n[[AWS Lambda]]\n\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/AWS-Fargate":{"title":"AWS Fargate","content":"\n# Definition\n\nFargate is a service offered by AWS that is responsible for managing infrastructure for the user. When you launch an [[notes/Elastic Compute Cloud (EC2)|Elastic Compute Cloud (EC2)]] instance, you also have to deal with security, patching and many other problems that you might not want to deal with. Fargate will be responsible for managing the infrastructure for you so you don't have to worry about any of those problems.\n\n## When to use Fargate?\n\nCompanies should use AWS Fargate when the machine which is hosting the application does not rely on specific configurations. Fargate excels at delivering power with simplicity, but sometimes companies need to have more freedom of configuration.","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/AWS-Lambda":{"title":"AWS Lambda","content":"\n# Definition\n\nAWS Lambda is a service provided by AWS that computes code without any server. You provide the code in any language that Lambda supports and it does the rest, auto-scaling, dealing with server allocation, security and much more.\n\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/AWS-S3":{"title":"AWS S3","content":"\n# Definition\n\nAmazon Simple Storage Service (S3) is a storage service offered by Amazon that lets you store files like images, PDFs, and many other file types. It lets you control these files through simple APIs and provides many benefits like high availability, security and performance.","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Architecture-Patterns":{"title":"Architecture Patterns","content":"\n\u003e **Font:** Software Architecture Patterns - Mark Richards\n\n# Introduction\n\nRecently, I've dedicated myself to a comprehensive study of architecture patterns, recognizing their importance within the realm of backend software engineering. I embarked on this journey by exploring relevant content on [roadmap.sh](https://roadmap.sh/backend). Then I came across a great book on the topic entitled **\"Software Architecture Patterns - Mark Richards\"**. I'm here to share some of the key takeaways from my studies. Feel free to explore the links if you wish to dive into other topics.\n\n## Layered Architecture\n\n[[Layered Architecture]]\n\nThe first pattern I want to talk about is the **layered architecture** pattern. This pattern is the standard for most Java E.E. applications and therefore is widely known by most architects, designers, and developers.\n\nA layered architecture consists of many **horizontal layers** that each take care of one specific task, this makes it possible to isolate changes to specific components in the architecture.\n\n## Event-driven Architecture\n\n[[Event-driven Architecture]]\n\nIn this architecture, the system is built around handling and responding to [[Event|events]]. Instead of executing a predefined sequence of steps, the system listens for [[Event|events]] and reacts accordingly. Events propagate in the system through the [[Pub-Sub Pattern]]\n\n## Microkernel Architecture\n\n[[Microkernal Architecture]]\n\nThe microkernel architecture pattern is a good choice for products that are meant to have plugins by default, such as operating systems, third-party products, and others. This pattern allows products to have extensions and plug them in easily to the main application.\n\n## Microservices Architecture\n\n## Space-based Architecture\n\n# Conclusion\n\n![pattern_analysis](notes/images/pattern_analysis.png)\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Broadcast":{"title":"Broadcast transmission","content":"\n# Definition\n\nThe communication channel is shared by all machines on the network. Packets sent by one machine are received by all the others. Packets inform their destination, so that only the correct machine processes the packet.\n\nIf a packet has a specific code on the receiver address, it can be received by all machines on the network, this is called **broadcasting**.\n\n# Examples\n\nWireless is a good example of a broadcast link.\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Broker-Topology":{"title":"Broker Topology","content":"\n# DEFINITION\n\nThe broker topology differs from the mediator topology in that there is no central [[notes/Mediator|Mediator]]; rather, the message flow is distributed across the [[Event Processors]] components in a chain-like fashion through a lightweight [[Message Broker]].\n\n## CONSIDERATIONS\n\nThe [[Event-driven Architecture]] pattern is a relatively complex pattern to implement, primarily due to its asynchronous distributed nature. When implementing this pattern, you must address various distributed architecture issues, such as [[remote process availability]], lack of responsiveness, and [[Message Broker]] reconnection logic in the event of a broker or [[Mediator]] failure.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Computer-Networks":{"title":"Computer Networks","content":"\n# Transmission Technologies\n\nThere are two types of transmission technologies:\n\n[[Broadcast]]\n\n[[Point-to-point transmission]]\n\n## Scale\n\nNetworks can also be classified by their effectiveness by the distance they cover. Different technologies are used at different scales.\n\n### Examples:\n\n[[Personal Area Network]]\n\n[[Local Area Network]]\n\n[[Metropolitan Area Network]]\n\n[[Wide Area Network]]\n\n![networks_by_scale](notes/images/networks_by_scale.png)\n\n## How to connected different types of networks together\n\nThe general name for a machine that makes a connection between two or more networks and provides the necessary translation, both in terms of hardware and software, is a **gateway**.\n\n## [[Protocol Hierarchies]]\n\nTo reduce their design complexity, most networks are organized as a stack of layers or levels, such as in a [[Layered Architecture]], each one built upon the one below it. The number of layers, the name of each layer, the contents of each layer, and the function of each layer differ from network to network. The purpose of each layer is to offer certain services to the higher layers while shielding those layers from the details of how the offered services are actually implemented. In a sense, each layer is a kind of virtual machine, offering certain services to the layer above it.\n\n## [[Network Software]]\n\nNetwork software refers to a collection of programs and applications designed to facilitate communication and data exchange between devices within a computer network. It plays a crucial role in performing connections and dealing with the unreliable environment which is the internet through the use of layers of abstraction.\n\n## [[OSI model]]\n\nThe **OSI (Open Systems Interconnection)** model is an international conceptual framework that standardizes the functions of computing system into seven distinct layers. Developed by the **International Organization for Standardization (ISO)**, it serves as a guideline to facilitate communication between different hardware and software components within a networked system.","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Connection-Oriented-Service":{"title":"Connection-Oriented Service","content":"\n# Connection-Oriented Service\n\nA connection oriented service works like a telephone service, they **establish** a connection, **use** the connection, and **end** the connection. Connection-oriented networks are generally used in scenarios where data integrity and reliability are critical for the application, such as:\n\n- **Online Gaming**: Many online multiplayer games utilize connection-oriented networks to maintain a reliable and low-latency connection between players, reducing lag and ensuring a smoother gaming experience.\n- **Video Streaming Services**: Connection-oriented networks are essential for video streaming platforms like Netflix and YouTube to deliver high-quality video content without buffering or interruptions.\n- **Email Services**: SMTP (Simple Mail Transfer Protocol) is commonly used for sending emails. SMTP establishes a connection between the mail client and the mail server to ensure that emails are reliably delivered and received.\n- **Voice over IP:** Voice over IP uses connection-oriented networks because the conversation must follow the flow, a receiver must not wait for a response and maybe never get it, reliability is extremely important for this use case.\n\n## Primitives (operations)\n\nThe connection-oriented service is specified by a set of primitives (operations) that are performed during a connection. Let's illustrate this interaction:\n\n- **LISTEN**: The server executes this operation to establish that it is ready to receive connections.\n- **CONNECT:** A client sends a packet to the server and waits for it to respond, this packet tells the server that the machine is trying to establish a connection.\n- **ACCEPT**: The server accepts the connection.\n- **RECEIVE:** The server performs this operation to be ready to receive messages by the client.\n- **SEND:** The client sends a message and waits for a response using RECEIVE.\n- **DISCONNECT:** The client terminates the connection after the communication.\n\n![connection_oriented_primitives](connection_oriented_primitives.png)\n\n\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Connectionless-Service":{"title":"Connectionless Service","content":"\n# Connectionless Service\n\nA connectionless service is modeled after the postal service. Messages have a **sender** and a **destination**. The message is then passed down from node to node until the destination receives it. Good examples of connectionless services are:\n\n- **Domain Name System (DNS)**: DNS is a fundamental service that translates human-readable domain names (e.g., [www.example.com](http://www.example.com/)) into IP addresses. DNS uses connectionless protocols like User Datagram Protocol (UDP) to quickly respond to queries without establishing a connection.\n- **Voice over IP (VoIP) - Signaling**: While VoIP for actual voice transmission prefers a connection-oriented approach for better quality, the signaling part of VoIP (e.g., SIP - Session Initiation Protocol) often uses connectionless UDP for faster call setup and teardown.\n- **IoT (Internet of Things) Devices**: Many IoT devices use connectionless networks to efficiently exchange data with central servers or cloud services without the need for maintaining a continuous connection.\n\n![connectionless_service](notes/images/connectionless_service_example.png)","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Dynamic-Design":{"title":"Dynamic Design","content":"\n# Definition\n\nIn a LAN (Local Area Network) network, dynamic allocation of channels refers to the process of assigning communication channels or frequencies to different devices or nodes on the network dynamically. It is a method used to manage and optimize the use of available channels in order to avoid interference and ensure efficient data transmission.\n\nDynamic allocation of channels is **particularly important in wireless LANs (WLANs)** where multiple devices communicate over the airwaves. In such networks, the available frequency spectrum is limited and shared among different devices. To prevent collisions and interference, a mechanism is needed to allocate channels in a way that minimizes conflicts and maximizes the overall network performance.\n\nOne common approach for dynamic channel allocation in WLANs is called \"Dynamic Frequency Selection\" (DFS). DFS involves using a set of predefined channels and dynamically selecting the most appropriate channel for each device based on various factors such as interference levels, signal strength, and channel utilization. By continuously monitoring the network conditions, devices can detect and avoid channels that are experiencing heavy interference, thereby improving the overall quality of communication.\n\nDynamic channel allocation can also be used in wired LANs, although it is less common. In wired networks, it typically involves the use of techniques such as time-division multiplexing (TDM) or frequency-division multiplexing (FDM) to allocate channels or time slots to different devices dynamically based on their bandwidth requirements.\n\nOverall, dynamic allocation of channels in LAN networks aims to optimize the use of available resources, reduce interference, and improve the efficiency of data transmission, ultimately enhancing the performance and reliability of the network.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Elastic-Compute-Cloud-EC2":{"title":"Elastic Compute Cloud (EC2)","content":"\n# Definition\n\nEC2 is a service by Amazon that lets you rent a virtual machine on the cloud. This service is \u003cu\u003emanaged by the user\u003c/u\u003e, so the user has the benefit of choice for the operating system, RAM, CPU and so on, but also has to update the system, apply security measures, and take care of every other aspect of the server.\n\n## When to use EC2?\n\nEC2 excels when projects have specific needs when it comes to infrastructure, EC2 is highly flexible to customization, which makes it the right candidate for such projects.\n\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Elastic-Container-Repository-ECR":{"title":"Elastic Container Repository (ECR)","content":"\n# Definition\n\nElastic Container Repository is a container registry owned by Amazon. ECR is responsible for storing docker images that are going to be used by other [[notes/AWS|AWS]] services.","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Elastic-Container-Service-ECS":{"title":"Elastic Container Service (ECS)","content":"\n# Definition\n\nAmazon Elastic Container Service, as the name implies, is a service offered by amazon to orchestrate containers, usually [[Docker]] containers. ECS sits on top of [[notes/Elastic Compute Cloud (EC2)|Elastic Compute Cloud (EC2)]] or [[AWS Fargate]] as the machines in which containers are going to run. \n\n## How does it work?\n\nFirst of all, we need a dockerfile from which the application will be built. The dockerfile will be responsible for starting up the application.\n\nAfter the dockerfile is created, we have to deploy it to [[Elastic Container Repository (ECR)]] which is a registry owned by Amazon to hold images.\n\nThen, you can define a \u003cu\u003etask\u003c/u\u003e using ECS. A task definition is an abstraction that is responsible for starting containers and dealing with ports for communication between containers. For instance, you might have a task that is responsible for two containers, a database container and an NodeJS application container.\n\n\n## What is a cluster?\n\nA cluster is a group of machines that will be used to execute tasks. You can use both [[notes/Elastic Compute Cloud (EC2)|Elastic Compute Cloud (EC2)]] or [[notes/AWS Fargate|AWS Fargate]] as machines. When tasks are executed, they are hosted on machines inside a cluster of choice.\n\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Elastic-Load-Balancer-ELB":{"title":"Elastic Load Balancer (ELB)","content":"\n# Definition\n\nELB is a service provided by AWS that does exactly what the name implies, balancing the load of requests between more than one server. Load balancing has the benefit of ensuring that when a server is down, the requests are going to point to another server, ensuring availability of the application.","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Event":{"title":"Event","content":"\n## Definition\n\n\u003eAn event is something that happens, especially when it is unusual or important.\n\nAn event can be thought of as something that *has happened and the organisation cares about*. Events represent the past and they are immutable by nature, meaning they cannot be changed once they are created.\n\n## Examples\n\nThere are some possible examples of events that might happen:\n\n- An event is sent when a user performs a login.\n- An event is sent when a user changes a record in a database.\n- An event is sent when a record is deleted from a database.\n\n## Event notification\n\nEvent notifications are sent from a system as simple notifications to other systems. The sender does not care about the response that other systems have to that event, the only thing it cares about is sending the notification.\n\n## Event-Carried State Transfer\n\nThese types of events carry state and are meant to be processed by other systems without the need of contacting the sender. A good example of this pattern being used is sending an event of a database change so that other systems can also change the same record on their databases.","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Event-Processors":{"title":"Event Processors","content":"\n# Definition\n\nThe event processor is responsible for executing the logic. The event processor uses modules to execute business logic. The event processors are \u003cu\u003eself-contained, meaning they cannot use other event processors to execute their logic.\u003c/u\u003e\n\n## How granular can they be?\n\nEvent processors need to be able to execute their task without depending on other event processors. If they can be split without creating dependency between the services, they should be split.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Event-driven-Architecture":{"title":"Event-driven Architecture","content":"\n# Definition\n\nIn this architecture, the system is built around handling and responding to [[Event|events]]. Instead of executing a predefined sequence of steps, the system listens for [[Event|events]] and reacts accordingly. Events propagate in the system through the [[Pub-Sub Pattern]]\n\n## When to use?\n\n- The project constantly needs to swap services.\n- The project needs Asynchronous Communication between services.\n- Performance and scalability are key factors to the project.\n\n## When not to use?\n\n- The project has a simple and linear workflow.\n- Single service applications -\u003e don't spread services if it does not make sense.\n- Lack of Event-Driven infrastructure such as a Messaging service like [[RabbitMQ]]\n\n## Topologies\n\nThe event-driven architecture has two very distinct topologies, we must study them separately:\n\n### Mediator Topology\n\n[[Mediator Topology]]\n\nTopology for requests that have many steps to complete its job.\n\n### Broker Topology\n\n[[Broker Topology]]\n\nfewer steps to complete its job.\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Layered-Architecture":{"title":"Layered Architecture","content":"\n\u003e **Font:** Software Architecture Patterns - Mark Richards\n\n# Layered Architecture\n\nLayered Architectures are widely used in software development in many fields, such as: networking, database systems, operating systems, web development, and many more. It is highly popular for its simplicity yet effectiveness for solving problems.\n\n![layered_architecture](notes/images/layered_architecture.png)\n\nWhen a request is being processed, it acts as a needle, piercing through the layers until it reaches the bottom one, then coming back with a response.\n\nWe are going to continue talking about layered architectures in the context of a backend applications since they are widely used there.\n\n## Interface Layer\n\nThe interface layer is responsible for receiving requests an returning responses to the client. The interface layer normally follows some type of protocol, such as [[GraphQL]], [[REST]], [[gRPC]], or any other.\n\n## Domain Layer\n\nIt is also called \"business logic layer\" and it is responsible for applying business logic to the request through modules and [[Use Cases]]. The domain layer is also responsible for: verifying the data sent by the request, dealing with errors, talking to the persistence layer, and managing state.\n\n## Persistence Layer\n\nThe persistence layer is responsible for communicating with the database layer. The persistence layer forms an API of operations that the domain layer can use to communicate with the database. The advantage of having a persistence layer is that the database layer is free to be swapped whenever the system requires and it also brings security to the database layer.\n\n## Database Layer\n\nThe only responsibility of this layer is storing data, it does not apply business logic or deals with state.\n\n## Helper Layer\n\nThis layer serves every other layer and offers some functionality, such as math functions, array manipulation, and other basic features that do not represent any other layer.\n\n## Infrastructure Layer\n\nThis layer also servers other layers and it responsible for offering fundamental functionality to the application, such as HTTP clients, dealing with environment variables, dealing with middlewares and configuration of external services.\n\n## When to use and not to use\n\nLayered architectures are the most widely spread architecture pattern in software development, they are very good for projects that are starting and do not have a clear perspective of which architecture pattern that they are going to use.\n\nThe downside with layered architectures is that they are usually slow in terms of processing requests, so an application that needs to be super fast might not use them. The image below shows some other aspects of layered architectures compared to other architecture patterns.\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Local-Area-Network":{"title":"Local Area Network","content":"\n# Definition\n\n**Local Area Network (LAN)** is a network that operates in a single building, like a house or an office, it connects all computers in that building.\n\nLocal area networks can be built using **Wireless** or **Cables**.\n\n## Access Point\n\nThe access point is the central device that distributes packets across all devices.\n\n![access_point](notes/images/access_point.png)\n\n## Wireless\n\nThere is a standard for wireless known as **WiFi**.\n\nWireless can be divided into two categories based on how the channel is allocated:\n\n[[Static Design]]\n\n[[Dynamic Design]]\n\n## Wired\n\nCompared to wireless, wired networks exceed in speed. It is like when you connect a computer to your home network through cables, it is going to be much faster than when you connect to it by air (wireless).\n\nA widespread topology for wired connections is called \\*\\*Ethernet.\n\nWired networks can also be divided into two categories based on how the channel is allocated:\n\n[[notes/Static Design|Static Design]]\n\n[[notes/Dynamic Design|Dynamic Design]]\n\n### Ethernet\n\nIn this topology, many computers are connected to a device called a **switch**, the switch has many ports that are connected to each computer, the job of the switch is receiving and sending packets through the network. Two or more switches can be connected to each other to offer more ports to connect to more computers.\n\n![ethernet](notes/images/Ethernet.png)\n\nIt is possible to create a **VLAN** or **Virtual LAN**, which colors the ports of the switch in specific color codes, where one color does not interact with another color, as if they were in different **LANs**.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Mediator":{"title":"Mediator","content":"\n# DEFINITION\n\nThe event mediator receives the initial event and **orchestrates** that event by sending additional asynchronous events to [[Event Channels]] to execute each step of the process.\n\nThe event mediator is a **core component** of the event driven architecture, it should be designed correctly for a good use of the [[Event-driven Architecture]]\n\nThe event mediator can be implemented in **many different ways** including the [[Spring Integration]]\n\nThe event mediator is middle man of a request:\n\n[[Initial Event]] =\u003e the event before the mediator.\n\n[[Processing Event]] =\u003e an event that is being processed by [[Event Processors]]\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Mediator-Topology":{"title":"Mediator Topology","content":"\n# Definition\n\nThe mediator topology is useful for events that have **multiple steps** and require some level of orchestration to process the event.\n\n## Main Concepts\n\nThe main idea behind the mediator topology is having a central component called the [[Mediator]] which is responsible for sitting between service components, these components communicate with each other \u003cu\u003ethrough the mediator.\u003c/u\u003e The mediator acts as a hub or a central point of control for communication.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Metropolitan-Area-Network":{"title":"Metropolitan Area Network","content":"\n# Definition\n\nThis network covers a city, a good example of **MANs** is the television networks. Televisions are connected to cables that are connected to antennas that receive signal from another antenna that sits on top of a hill and distribute signal.\n\n![metropolitan_area_network](notes/images/Metropolitan_Area_Network.png)\n\nCable television is not the only MAN, though. Recent developments in high-\nspeed wireless Internet access have resulted in another MAN, which has been\nstandardized as IEEE 802.16 and is popularly known as [[WiMAX]].\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Microkernal-Architecture":{"title":"Microkernal Architecture","content":"\n\u003e **Font:** Software Architecture Patterns - Mark Richards\n\n# Introduction\n\nThe Microkernel architecture pattern consists of two main components, the _core system_ and the _plugins_. The _core system_ is responsible for providing the main functionality of the application, whereas the _plugins_ are responsible for extending the application with new features that are completely isolated from the _core system_ as illustrated in the following image.\n\n![microkernel_architecture](microkernel_architecture.png)\n\n## The VSCode Code Editor\n\nA good example of an application that uses this pattern is the **VSCode Code Editor**. Once you download it, you are presented with the _core functionality_ that every code editor should provide. Once you start adding _plugins_, the editor starts taking another shape that is completely customized for your needs.\n\n## Market Advantages\n\nA good advantage of writing software using the _Microkernel Pattern_ is that you can leverage the creation of _plugins_ to third party companies, only providing them with documentation and frameworks on how to connect with the main application, building an ecosystem of plugins for every type of user.\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Network-Software":{"title":"Network Software","content":"\n# Summary\n\nNetworks are a stack of layers. Each layer offers a service.\n\nServices respect [[Protocols]] to work. If the protocol is not followed, communication may be impossible.\n\n## [[Connection-Oriented Service]] vs [[Connectionless Service]] \n\nA [[Connection-Oriented Service]] works like a telephone service, they **establish** a connection, **use** the connection, and **end** the connection\n\nA [[Connectionless Service]] is modeled after the postal service. Messages have a **sender** and a **destination**. The message is then passed down from node to node until the destination receives it.\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/OSI-model":{"title":"OSI model","content":"\n![OSI_model.png](OSI_model.png)\n\n# OSI model\n\nThe **OSI (Open Systems Interconnection)** model is an international conceptual framework that standardizes the functions of computing system into seven distinct layers. Developed by the **International Organization for Standardization (ISO)**, it serves as a guideline to facilitate communication between different hardware and software components within a networked system. Let's discuss each layer:\n\n## The Physical Layer\n\nThe **physical layer** is responsible for sending bits over wire from one machine to another. This layer is concerned about guaranteeing that every single bit is received the same, without inversion.\n\n## The Data Link Layer\n\nThe main responsibility of the **data link layer** is to guarantee that messages are received free of errors, it does that by breaking messages into **data frames** and sending them separately. When a data frame is lost, the **data link layer** is smart enough to send another data frame until the message is completely received by the client.\n\n## The Network Layer\n\nThe **network layer** is concerned about routing packets from the origin to the destination. The **network layer** creates the routes and it also deals with connection between different networks that might follow different protocols.\n\n## The Transport Layer\n\nThe **transport layer** is responsible for receiving a message from the layers above it and splitting the message into packets. The transport layer also guarantees that end-to-end communication works smoothly in the network.\n\n## The Session Layer\n\nThe **session layer** allows users on different machines to establish sessions between them.\n\n## The Presentation Layer\n\nThe **presentation layer** looks at the packets and ensures that computers of different types can understand the message being sent. It functions as a sort of translator that helps computers understand each other regardless of their language.\n\n## The Application Layer\n\nThe **application layer** holds protocols that will be used by users, such as the [[HTTP]].","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Observer-Pattern":{"title":"Observer Pattern","content":"\n**Observer** is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.\n\n#work-in-progress ","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Personal-Area-Network":{"title":"Personal Area Network","content":"\n# Definition\n\nLet devices communicate over the range of a person.\n\n## Examples\n\n### Bluetooth\n\nIt uses the master-slave paradigm, where the master is the main component, and the slaves are the components that are connecting to the master. For example: A computer might be the master and a mouse might be the slave.\n\n![bluetooth](notes/images/bluetooth_networks.png)\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Point-to-point-transmission":{"title":"Point-to-point transmission","content":"\n# Definition\n\nin a point-to-point transmission, little messages called **packets** are sent through a path of computers.\n\nPoint-to-point transmission excels at finding the shortest path to the destination.\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Protocol-Hierarchies":{"title":"Protocol Hierarchies","content":"\n## Definition\n\nTo reduce their design complexity, most networks are organized as a stack of layers or levels, each one built upon the one below it. The number of layers, the name of each layer, the contents of each layer, and the function of each layer differ from network to network. The purpose of each layer is to offer certain services to the higher layers while shielding those layers from the details of how the offered services are actually implemented. In a sense, each layer is a kind of virtual machine, offering certain services to the layer above it.\n\n![layered_network](notes/images/layered_network.png)\n\n![protocols](notes/images/protocol_hierarchies_example_image.png)\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Protocols":{"title":"Protocols","content":"\n# Definition\nProtocols are a set of rules that govern how services interact with each other.\n\n## Analogy\nIn society, when a woman is introduced to a man, she may choose to stick her hand. He, in turn, might choose to kiss it if she is a princess or shake it if she is a lawyer. If none is chosen, communication might not work properly.","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Pub-Sub-Pattern":{"title":"Pub-Sub Pattern","content":"\n# Definition\n\nThis pattern works much like the [[Observer Pattern]], events are **published (pub)** by a service and other services can **subscribe (sub)** to the events that interest them. When an event is created, it is sent to all subscribers and then they perform their actions subsequently.\n\n## What is the topic queue?\n\nIn pub-sub systems, a topic represents a specific **category or subject of events**. Publishers generate events and assign them to specific topics, while subscribers express their interest in **receiving events from specific topics**.The [[Topic Queue]] acts as an intermediary between publishers and subscribers.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/RabbitMQ":{"title":"RabbitMQ","content":"\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Round-robin-algorithm":{"title":"Round-robin algorithm","content":"\n# Definition\n\nThe Round-Robin algorithm is a scheduling algorithm used in computer systems and networks to manage the allocation of resources or the execution of processes. It is commonly used in operating systems, task scheduling, and load balancing.\n\nIn the context of task scheduling, the Round-Robin algorithm is designed to provide fair and equal access to system resources for multiple processes. It works by assigning a fixed time quantum or time slice to each process in a cyclic manner. Each process is allowed to execute for a specified time quantum, and then it is preempted, allowing the next process in the queue to execute.\n\nIn the context of computer networks, the round-robin algorithm divides time for each computer connected to the channel, so each computer can receive **packets** for the amount of time allocated to it in a queue manner.\n\nThe algorithm operates based on a circular queue or a ready queue, where processes are placed in a particular order. When a process has completed its time quantum, it is moved to the end of the queue, and the next process in line gets a chance to execute. This process continues until all processes have completed their execution or until a specific termination condition is met.\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Routers":{"title":"Routers","content":"\n# Definition\n\nrouters are specialized computers that connect two or more transmission lines. When data\narrive on an incoming line, the router must choose an outgoing line on which to forward them.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Static-Design":{"title":"Static Design","content":"\n# Definition\n\nA typical static allocation would be to divide time into discrete intervals and use a [[Round-robin algorithm]], allowing each machine to broadcast only when its time slot comes up.\n\nStatic allocation wastes channel, because not all computers on the network are going to be used all the time, so the channel has time slots that are not being used.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Topic-Queue":{"title":"Topic Queue","content":"\n# Definition\n\ntopic queue, also known as a message queue, is a data structure that manages the order and delivery of messages within a messaging system. It is commonly used in distributed systems and communication protocols to enable asynchronous communication between different components or services.\n\nIn a topic queue, messages are sent by a producer and received by one or more consumers. The producer adds messages to the queue, and the consumers retrieve messages from the queue in the order they were added. This allows for decoupling and independent processing of messages, as producers and consumers don't need to interact directly or be available at the same time.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Transmission-Lines":{"title":"Transmission Lines","content":"\n# Definition\n\nTransmission lines move bits between the machines, they can be made of optical fiber, copper wire, or even radio links.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Untitled":{"title":"Untitled","content":"","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Untitled-1":{"title":"Untitled 1","content":"","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/WiMAX":{"title":"WiMAX","content":"\n#not-started\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]},"/notes/Wide-Area-Network":{"title":"Wide Area Network","content":"\n# Definition\n\n**WANs** consist of networks that span across a country.\n\n## Hosts\n\nHosts are computers that are connected to the subnet and need to communicate with each other or run applications.\n\n## Subnet\n\nCan be simply perceived as a collection of lines and routers that connect computers.\n\nThe WAN as we have described it looks similar to a large wired LAN. There are some differences, the most important of them being that LANs are a bunch of computers connected to each other, in WANs, you might have computers connected to each other or even LANs connected to each other.\n\nThe job of the subnet is carrying messages from host to host. The subnet consists of two distinct components:\n\n[[Transmission Lines]]\n\n[[Routers]]\n\nWANs can be connected to each other through a cable, like the image below:\n\n![wide_area_network](notes/images/wide_area_network.png)\n\nOr they can be connected through the internet and a [[VPN]], as shown in the image below:\n\n![wide_area_network_internet](notes/images/wide_area_network_internet.png)\n\nIf two routers that are not directly connected to each other wish to communicate, they have to do it indirectly through other routers, creating a path of communication that is the shortest and most effective. The path is determined by a **routing algorithm**.\n\n#work-in-progress\n","lastmodified":"2023-08-06T16:03:58.610982234Z","tags":[]}}