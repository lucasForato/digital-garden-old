{"/":{"title":"ü™¥ Forato's Digital Garden","content":"# Home\n\nBelow is a list of all the posts in this digital garden.\n\n## Architecture Patterns\n[[notes/test|test]]","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/notes/test":{"title":"Architecture Patterns","content":"\n# Architecture Patterns\n\nhello world\n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":["architecture patterns"]},"/private/legacy/API-Gateway":{"title":"API Gateway","content":"# DEFINITION\nWhat is an API gateway?\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/API-Manager":{"title":"API Manager","content":"# DEFINITION\nWhat is an API manager?\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/API-REST-based-topology":{"title":"API REST-based topology","content":"\n# DEFINITION\n\nThis topology for [[Microservices Architecture]] is useful for websites that expose\n**small, self-contained individual services** through some sort of API. In this topology, these fine-grained service components are typically accessed using a [[REST]]-based interface\nimplemented through a separately deployed web-based API layer.\n\n---\n\n### EXAMPLE IMAGE\n\n![[API REST-based microservices topology Image.png]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/ActiveMQ":{"title":"ActiveMQ","content":"# DEFINITION\nAn open-source message-oriented middleware that supports the Java Message Service (JMS) standard. ActiveMQ provides features like message persistence, high availability, and clustering for scalable message processing.\n\n---\n## REVIEWS\n#‚åõ\n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Adapter":{"title":"Adapter","content":"# DEFINITION\nThe adapter will act as a bridge that connects the [[Plugins]] to the [[Core]] of the [[Microkernel Architecture]]. The adapter makes sure that both APIs can understand each others contract.\n\n---\n## WHEN TO USE\nThe adapter should be used when you are not really sure the contract that a specific [[Plugins]] will have because they will be developed by third-party.\n\n---\n## REVIEWS\n#‚≠ê  \n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Apache-Kafka":{"title":"Apache Kafka","content":"# DEFINITION\nA distributed streaming platform that provides high-throughput, fault-tolerant messaging. Kafka is known for its **scalability**, **durability**, and **ability to handle real-time data streams**.\n\n---\n## REVIEWS\n#‚åõ\n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Application-REST-based-topology":{"title":"Application REST-based topology","content":"# DEFINITION\n\n---\n## LINKS TO\nIt is like the[[API REST-based topology]], but we have a layer called the **User Interface Layer**, which is responsible for routing the requests to the standalone services. Another difference to point out is that services are larger, as you can see on the\n\n---\n## RECOMMENDED FOR\nSmall and medium sized business with easy logic to be applied.\n\n---\n### EXAMPLE IMAGE\n![[Application API REST-based microservices architecture Image.png]]\n\n---\n## REVIEWS\n#‚åõ ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Architecture-Patterns":{"title":"Architecture Patterns","content":"\n[[Event-driven Architecture]] =\u003e highly scalable, but difficult to maintain.\n\n---\n[[Layered Architecture]] =\u003e not so highly scalable, but very easy to maintain.\n\n---\n[[Microkernel Architecture]] =\u003e an architecture pattern that allows plugins and is used in some operating systems.\n\n---\n[[Microservices Architecture]] =\u003e an architecture pattern that isolates services and connects them via API.\n\n---\n[[Space-based Architecture]] =\u003e often referred to as the **cloud architecture**.\n\n---\n## REVIEWS\n#‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Architecture-Patterns-Analysis":{"title":"Architecture Patterns Analysis","content":"![[Architecture Patterns Analysis Image.png]]","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Asynchronous-Communication":{"title":"Asynchronous Communication","content":"# DEFINITION\nasynchronous communication allows services to send messages and \u003cu\u003econtinue\u003c/u\u003e with their own processing without blocking or waiting for a response.\n\n---\n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Broker-Topology":{"title":"Broker Topology","content":"# DEFINITION\nThe broker topology differs from the mediator topology in that there is no central [[Event Mediator]]; rather, the message flow is distributed across the [[Event Processors]] components in a chain-like fashion through a lightweight [[Message Broker]].\n\n---\n## EXAMPLE BY OREILLY\n[[Relay Race Example]]\n\n---\n## CONSIDERATIONS\nThe [[Event-driven Architecture]] pattern is a relatively complex pattern to implement, primarily due to its asynchronous distributed nature. When implementing this pattern, you must address various distributed architecture issues, such as [[remote process availability]], lack of responsiveness, and [[Message Broker]] reconnection logic in the event of a broker or [[Mediator]] failure.\n\n---\n### EXAMPLE IMAGE\n![[Broker topology Image.png]]\n\n---\n### EXAMPLE IMAGE\nThis is how a chain of event processors is executed:\n![[Event processor Image.png]]\n\n---\n## REVIEWS\n#‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Brokers":{"title":"Brokers","content":"# DEFINITION\nA broker is responsible for routing the [[request]] to the correct service that will handle that request.  \n\n---\n## REVIEWS\n#‚≠ê\n\n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Business-layer":{"title":"Business layer","content":"\n# DEFINITION\nIn a layered architecture, the business layer, also known as the \u003cu\u003elogic layer, application layer or domain layer\u003c/u\u003e, is responsible for handling the business logic and rules of an application or system. It sits between the presentation layer (user interface) and the data layer (data storage and retrieval).\n\n---\n## RESPONSIBILITIES\n- Handling business logic and rules.\n- Handling data processing.\n- Enforcing security and authorization.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Centralized-Messaging-topology":{"title":"Centralized Messaging topology","content":"# DEFINITION\nIt is similar to the [[Application REST-based topology]] but instead of a REST API, the Centralized Messaging topology has a lightweight [[Message Broker|message broker]] layer to deal with communication between services.\n\n---\n## WHEN TO USE\nThe centralized messaging topology is typically found in larger business applications or applications requiring more sophisticated control over the [[Transport Layer|transport layer]] between the user interface and the service components.\n\n---\n### EXAMPLE IMAGE\n![[Centralized messaging topology microservices architecture Image.png]]\n\n---\n## REVIEWS\n#‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Components-in-a-Mediator-Topology":{"title":"Components in a Mediator Topology","content":"# THOUGHT\nthere are four types of architectural components in a [[Mediator Topology]].\n\n---\n[[Event Queues]]\n\n---\n[[Event Mediator]]\n\n---\n[[Event Channels]]\n\n---\n[[Event Processors]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Computer-Networks":{"title":"Computer Networks","content":"# DEFINITION\nA collection of autonomous computers interconnected by a single technology.\nNetworks have many forms and shapes, the most well know network of computers is the [[Internet]].\n\n---\n## WHY CARE ABOUT COMPUTER NETWORKS?\n- resource sharing across many computers\n- information \n\n---\n## NETWORK HARDWARE\nthere are two types on transmission technologies:\n[[Broadcast]]\n[[Point-to-point]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Concurrency":{"title":"Concurrency","content":"# DEFINITION\nConcurrency refers to the ability of a system or program to handle multiple tasks or [[Processes]] \u003cu\u003esimultaneously\u003c/u\u003e. It is a property of systems that allows multiple actions to occur concurrently, without one action necessarily waiting for the other to complete. In other words, it enables overlapping or parallel execution of tasks to improve efficiency and responsiveness.\n\n---\n## PROBLEMS\n[[Race conditions]]\n[[Deadlocks]]\n[[Starvation]]\n[[Data inconsistency]]\n[[Performance overhead]]\n\n---\n## REVIEWS\n#‚≠ê  \n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Contract":{"title":"Contract","content":"# DEFINITION\n\nA group of rules that are usually used by the API.\n\n---\n\n## EXAMPLE\n\nThere are some contracts being established below. Contracts represent the way the API will transfer data. What you have to send and what you get from it.\n\n```graphql\ntype User {\n  email: String\n  name: String\n}\n\ntype Query {\n  user(id: String!): User\n}\n```\n\n---\n## REVIEWS\n#‚≠ê ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Core":{"title":"Core","content":"# DEFINITION\n\nThe core of a [[Microkernel Architecture]] is **only the most important code** to solve some problem and has the capability to connect to other systems.\n\n---\n## REVIEWS\n#‚åõ\n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/DRY":{"title":"DRY","content":"\n# DEFINITION\n\n**Don't Repeat Yourself**. You should never rewrite code that has already been written.\n\n---\n\n## RULE OF THUMB\n\nUpon seeing repetition more than 3 times, you should put that code in a class of function and it will not be repeated again.\n\n---\n## REVIEWS\n#‚≠ê ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Data-Grid":{"title":"Data Grid","content":"In a [[Space-based Architecture]], a data grid refers to a distributed and scalable data storage and processing system that spans multiple nodes or servers in a network. It is designed to handle large volumes of data and provide high-performance access and manipulation capabilities.\n\n---\n## FEATURES\nOne of the key features of a data grid is its ability to handle data locality and distribution transparently. Data is typically replicated across multiple nodes to provide fault tolerance and high availability. The data grid also supports dynamic data partitioning and load balancing, allowing it to scale horizontally by adding or removing nodes as needed.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Data-inconsistency":{"title":"Data inconsistency","content":"# DEFINITION\nIn a concurrent system, when multiple [[Thread|threads]] or [[Processes|processes]] access and modify shared data simultaneously, it can lead to data inconsistency. Data inconsistencies occur when the interleaved execution of these operations results in incorrect or unexpected values.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Deadlocks":{"title":"Deadlocks","content":"# DEFINITION\nA deadlock occurs when two or more processes or threads are unable to proceed because \u003cu\u003eeach is waiting for the other to release a resource\u003c/u\u003e. This situation leads to a standstill, where no progress can be made, and the system becomes unresponsive.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Dependency-Inversion":{"title":"Dependency Inversion","content":"# DEFINITION\nThis principle says a Class should not be fused with the tool it uses to execute an action. Rather, it should be fused to the interface that will allow the tool to connect to the Class.\n\nIt also says that both the Class and the interface should not know how the tool works. However, the tool needs to meet the specification of the interface.\n\n---\n## GOAL\nThis principle aims at reducing the dependency of a high-level Class on the low-level Class by introducing an interface.\n\n---\n## EXAMPLE IMAGE\n![[Dependency Inversion Image.png]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Deployment-Manager":{"title":"Deployment Manager","content":"# DEFINITION\n\nThe deployment-manager component manages the dynamic startup and shutdown of [[Processing Unit|processing units]] based on load conditions. This component continually monitors response times and user loads, and starts up new processing units when load increases, and shuts down processing units when the load decreases. It is a **critical component** to achieving variable scalability needs within an application.\n\n---\n## REVIEWS\n#‚åõ\n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Event":{"title":"Event","content":"## DEFINITION\nAn event can be thought of as a **trigger** or **notification** that something has happened or changed in the system. It could be a user action, like clicking a button, or a system event, like a new message arriving.\n\n---\n## REVIEWS\n#‚≠ê ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Event-Channels":{"title":"Event Channels","content":"# DEFINITION\nAn event channel acts as a central hub or intermediary, where components can publish events and subscribe to events of interest. When a component publishes an event to the event channel, it becomes available for consumption by other interested components that have subscribed to that particular event. the component that publishes the event is called [[Event Mediator]], the components that are subscribed are called [[Event Processors]].\n\n---\n## HOW THEY WORK\nThe event channel operates based on a [[Pub-Sub Pattern|publish-subscribe mechanism]]. Components can publish [[Event|events]] to the channel without needing to know which specific components will receive them. Similarly, components interested in specific types of events can subscribe to the channel without needing to know which components will publish those events.\n\n---\n## KEY CONCEPTS\n**Decoupling** -\u003e Event channels decouple the sender of an event from its receivers. Components only need to be aware of the event channel and the events they are interested in, rather than having direct knowledge of other components.\n\n**Flexibility** -\u003e The use of event channels allows components to dynamically join or leave the communication network without impacting the overall system. Components can subscribe to new event types or unsubscribe from existing ones based on their changing requirements.\n\n**Scalability** -\u003e Event channels can handle a large number of events and distribute them efficiently to the subscribed components. This scalability ensures that as the system grows, the communication infrastructure can handle the increased event traffic.\n\n---\n### EXAMPLE IMAGE:\n![[Request Example Image.png]]\n\n---\n## REVIEWS\n#‚≠ê  ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Event-Mediator":{"title":"Event Mediator","content":"# DEFINITION\nThe event mediator receives the initial event and **orchestrates** that event by sending additional asynchronous events to [[Event Channels]] to execute each step of the process.\n\nThe event mediator is a **core component** of the event driven architecture, it should be designed correctly for a good use of the [[Event-driven Architecture]]\n\nThe event mediator can be implemented in **many different ways** including the [[Spring Integration]]\n\nThe event mediator is middle man of a request:\n[[Initial Event]] =\u003e the event before the mediator\n[[Processing Event]] =\u003e an event that is being processed by [[Event Processors]]\n\n---\n\n## REMINDS ME OF\n\nthe event mediator reminds me of a [[Use Case]] in [[DDD]] architecture.\n\n---\n\n### EXAMPLE IMAGE\n\n![[Request Example Image.png]]\n\n---\n\n### MEDIATOR EXAMPLES\n\n[[Airflow]]\n\n---\n## REVIEWS\n#‚≠ê ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Event-Processors":{"title":"Event Processors","content":"# DEFINITION\nThe event processor is responsible for executing the logic. The event processor uses modules to execute business logic. The event processors are \u003cu\u003eself-contained, meaning they cannot use other event processors to execute their logic.\u003c/u\u003e\n\n---\n## HOW GRANULAR CAN THEY BE?\nEvent processors need to be able to execute their task without depending on other event processors. If they can be split without creating dependency between the services, they should be split.\n\n---\n### EXAMPLE IMAGE\n![[Request Example Image.png]]\n\n---\n## REVIEWS\n#‚≠ê ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Event-Queues":{"title":"Event Queues","content":"# DEFINITION\nThe event queue is the beginning of every request. The queue works in a [[Pub-Sub Pattern|publish-subscribe mechanism]] where an event is published and has to wait until the [[Event Mediator]] can handle the request.\n\n---\n## FLOW\nTransports the event to the Event Queue. it then transports the request to the [[Event Mediator]] when it is ready to handle the request.\n\n---\n## EXAMPLE IMAGE\n![[Request Example Image.png]]\n\n---\n## REVIEWS\n#‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Event-driven-Architecture":{"title":"Event-driven Architecture","content":"# DEFINITION\nIn this architecture, the system is built around handling and responding to [[Event|events]]. Instead of executing a predefined sequence of steps, the system listens for [[Event|events]] and reacts accordingly. Events propagate in the system through the [[Pub-Sub Pattern]]\n\n---\n## WHEN TO USE?\n- The project constantly needs to swap services.\n- The project needs [[Asynchronous Communication]] between services.\n- Performance and scalability are key factors to the project.\n\n---\n## WHEN NOT TO USE?\n- The project has a simple and linear workflow.\n- Single service applications -\u003e don't spread services if it does not make sense.\n- Lack of Event-Driven infrastructure such as a Messaging service like [[RabbitMQ]]\n\n---\n## TOPOLOGIES\nThe event-driven architecture has two very distinct topologies, we must study them separately:\n[[Mediator Topology]] =\u003e topology for requests that have many steps to complete its job.\n[[Broker Topology]] =\u003e fewer steps to complete its job.\n\n---\n## EXAMPLE IMAGE\n![[Event-driven architecture Image.png]]\n\n---\n## PATTERN ANALYSIS\n[[Architecture Patterns Analysis]]\n\n---\n## REVIEWS\n#‚≠ê‚≠ê‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Global-Modules":{"title":"Global Modules","content":"# DEFINITION\n\nGlobal modules is a concept introduced by the [[Layered Architecture]] pattern, but there they are know as open layers. In [[NestJS]], global modules are modules that can be accessed by any other module in an application.\n\n---\n\n## WHEN TO USE?\n\nGlobal modules should be used for modules that are extensively used in the application, such as helper modules, database connections, and so on.\n\n---\n## REVIEWS\n#‚åõ ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Horizontal-Scalability":{"title":"Horizontal Scalability","content":"\n# DEFINITION\nHorizontal scaling is when we scale by increasing the number of machines for the system. \n\n---\n## EXAMPLE IMAGE\n![[Horizontal Scalability Image.png]]\n\n---\n## LINKS TO\n[[Vertical Scalability]]\n\n---\n## REVIEWS\n#‚≠ê  ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Initial-Event":{"title":"Initial Event","content":"# DEFINITION\nthe initial event is before the [[Mediator]] enters in action, the original event sent by the client.\n\n---\n## REVIEWS\n#‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Interface-Segregation":{"title":"Interface Segregation","content":"# DEFINITION\nA Class should perform only actions that are needed to fulfil its role.\n\n---\n## GOAL\nThis principle aims at splitting a set of actions into smaller sets so that a Class executes ONLY the set of actions it requires.\n\n---\n## EXAMPLE IMAGE\n![[Interface Segregation Image.png]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Layered-Architecture":{"title":"Layered Architecture","content":"# DEFINITION\nThis pattern is the de facto standard for most Java EE applications and therefore is widely known by most architects, designers, and developers.\n\nA layered architecture has \u003cu\u003emany horizontal layers\u003c/u\u003e that each take care of \u003cu\u003eone specific task\u003c/u\u003e, this makes it possible to isolate changes to specific components.\n\n---\n## LAYERS\n[[Transport Layer]] -\u003e responsible for interacting with the user, listening for requests and delivering responses.\n[[Presentation layer]] -\u003e responsible for displaying the result and processing user requests.\n[[Business layer]] -\u003e entities, use cases.\n[[Persistence layer]] -\u003e responsible for talking to the database layer.\n\n---\n## OPEN LAYERS\nAn open layer is a layer that is open to be accessed by any layer, requests can bypass this layer since it is open. There should be some to no open layers in an application, only layers like service workers that have the task to help the entire application. In [[NestJS]], we call these layers [[Global Modules]].\n\n---\n## WHEN TO USE?\nYou should use a layered architecture as a \u003cu\u003egood solid starting point for an application\u003c/u\u003e, mostly when you don't have an architecture to follow yet. But it usually leads to a monolithic application and can have issues with performance.\n\n---\n## PATTERN ANALYSIS\n[[Architecture Patterns Analysis]]\n\n---\n## REVIEWS\n#‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Learning-with-Renan":{"title":"Learning with Renan","content":"# TALKS\n[[Talk 1]] -\u003e talked mainly about architecture patterns.\n[[Talk 2]]","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Linux-file-system":{"title":"Linux file-system","content":"# IMAGE\n![[linux file system image.jpeg]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Liskov-Substitution":{"title":"Liskov Substitution","content":"# DEFINITION\nThe¬†**child**¬†Class should be able to process the same requests and deliver the same result as the¬†**parent**¬†Class or it could deliver a result that is of the same type.\n\nThe picture shows that the¬†**parent**¬†Class delivers Coffee(it could be any type of coffee). It is acceptable for the¬†**child**¬†Class to deliver Cappucino because it is a specific type of Coffee, but it is NOT acceptable to deliver Water.\n\nIf the¬†**child**¬†Class doesn‚Äôt meet these requirements, it means the¬†**child**¬†Class is changed completely and violates this principle.\n\n---\n## GOAL\nThis principle aims to enforce consistency so that the parent Class or its child Class can be used in the same way without any errors.\n\n---\n## EXAMPLE IMAGE\n![[Liskov Substitution Image.png]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Mediator-Topology":{"title":"Mediator Topology","content":"# DEFINITION\nThe mediator topology is useful for events that have **multiple steps** and require some level of orchestration to process the event.\n\n---\n## MAIN CONCEPT\nThe main idea behind the mediator topology is having a central component called the [[Mediator]] which is responsible for sitting between service components, these components communicate with each other \u003cu\u003ethrough the mediator.\u003c/u\u003e The mediator acts as a hub or a central point of control for communication.\n\n---\n### EXAMPLE IMAGE\n![[Event-driven architecture Image.png]]\n\n---\n## EXAMPLE\n[[Oreilly Stock Trade Example]]\n\n---\n## REVIEWS\n#‚≠ê ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Message-Broker":{"title":"Message Broker","content":"\n# DEFINITION\n\nA message broker is a key component in a messaging system that acts as an intermediary for communication between different applications or systems. It enables the asynchronous exchange of messages by receiving messages from senders and delivering them to the **intended recipients**.\n\n---\n\n## EXAMPLE BY COWORKER\n\n[[nginx]]\n\n---\n\n%%REVIEW%%\n\n## EXAMPLES\n\n[[RabbitMQ]]\n[[Apache Kafka]]\n[[ActiveMQ]]\n\n---\n## REVIEWS\n#‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Messaging-Based-Architecture":{"title":"Messaging Based Architecture","content":"# DEFINITION\n\nA messaging-based architecture is a design approach where systems communicate by **sending messages** to each other. Instead of directly calling methods or services, components exchange messages through a messaging infrastructure. This approach promotes loose coupling, scalability, and fault tolerance, allowing systems to communicate asynchronously and enabling integration between diverse applications.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Messaging-grid":{"title":"Messaging grid","content":"# DEFINITION\n\nThe messaging grid manages input request and session information. When a request comes into the [[Virtualized Middleware]] component, the messaging-grid component determines which active [[Processing Unit]] components are available to receive the request and forwards the request to one of those processing units. The complexity of the messaging grid can range from a simple [[round-robin algorithm]] to a more complex [[next-available algorithm]] that keeps track of which request is being processed by which processing unit.\n\n---\n\n## EXAMPLE IMAGE\n\n![[Messaging-grid component.png]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Microkernel-Architecture":{"title":"Microkernel Architecture","content":"# DEFINITION\nthe microkernel Architectural pattern is netural for applications that have [[Plugins]]. They are natural for that type of work because it is easy to implement [[Plugins]].\n\n---\n## COOL FACT\nMany operating systems apply the microkernel architecture.\n\n---\n### EXAMPLE IMAGE\n![[Microkernel architecture pattern Image.png]]\n\n---\n## APPS THAT USE\n- VS Code\n- Linux\n- Mac\n\n---\n## PATTERN ANALYSIS\n[[Architecture Patterns Analysis]]\n\n---\n## REVIEWS\n#‚≠ê ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Microservices-Architecture":{"title":"Microservices Architecture","content":"# DEFINITION\nIn a microservices architecture, we deploy separated [[Service Components]] that act as building blocks that together can perform all the actions of the application.\n\n---\n## EXAMPLE IMAGE\n![[Microservices Architecture Pattern Image.png]]\n\n---\n## LINKS TO\na Microservices Architecture was an evolution of the [[Monolithic Application]]\n\n---\n## TOPOLOGIES\nThere are three main ways to develop a microservices architecture.\n- [[API REST-based topology]]\n- [[Application REST-based topology]]\n- [[Centralized Messaging topology]]\n\n---\n# CONSIDERATIONS\nOne of the main challenges of the microservices architecture pattern is determining the correct **level of granularity** for the service components. If service components are too coarse-grained you may not realize the benefits that come with this architecture pattern (deployment, scalability, testability, and loose coupling). However, service components that are too fine-grained will lead to service [[Orchestration|orchestration]] requirements, which will quickly turn your lean microservices architecture into a heavyweight service-oriented architecture, complete with all the complexity, confusion, expense, and fluff typically found with SOA based applications.\n\nIt is always a good idea to apply the [[DRY]] principal, but sometimes you can repeat code from one [[Service Components|service component]] in another in order to avoid dependency between [[Service Components|service components]].\n\nYou should usually avoid dependency between [[Service Components|service components]] in a request, meaning a request should activate 1 [[Service Components|service component]], no more than that.\n\n---\n## PATTERN ANALYSIS\n[[Architecture Patterns Analysis]]\n\n---\n## REVIEWS\n#‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Monolithic-Application":{"title":"Monolithic Application","content":"# DEFINITION\n\n**A Monolithic Application** is an application that usually follows a [[Layered Architecture|layered architecture]]. It is a unique service that is responsible for **all** functionality in a system.\n\n---\n## REVIEWS\n#‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê\n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/NestJS":{"title":"NestJS","content":"# DEFINITION\n\nNestJS is a NodeJS backend framework that works very well as a starting point for a backend application, usually using the [[Layered Architecture]].\n\n---\n\n## CONCEPTS\n\n[[Global Modules]]\n\n---\n## REVIEWS\n#‚≠ê‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Observer-Pattern":{"title":"Observer Pattern","content":"# DEFINITION\n\n---\n\n## RESOURCE\n\n[click here to open resource](https://refactoring.guru/pt-br/design-patterns/observer)\n\n---\n## REVIEWS\n#‚åõ\n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Open-Closed":{"title":"Open-Closed","content":"# DEFINITION\nClasses should be open for extension but closed for modification.\n\n## GOAL\nThis principle aims to extend a Class‚Äôs behavior without changing the existing behavior of that Class. This is to avoid causing bugs wherever the Class is being used.\n\n---\n## EXAMPLE IMAGE\n![[Open-Closed Image.png]]\n\n---\n## CONSIDERATIONS\nThis principle reminds me of a [[Plugins|plugin]] because a plugin is simply an \u003cu\u003eextension\u003c/u\u003e of a class. A chrome plugin only respects the interfaces that chrome offers, \u003cu\u003eit does not know anything about chrome, and chrome does not know anything about the plugin\u003c/u\u003e, but they can connect with each other because the browser is open to extensibility.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Orchestration":{"title":"Orchestration","content":"\n# DEFINITION\n\nOrchestration is commonly used in various contexts, including [[Microservices Architecture]], distributed systems, workflow management systems, and containerized environments. It allows developers and system administrators to automate complex processes, coordinate interactions between different [[Service Components]], and streamline the execution of applications or services to achieve efficient and reliable results.\n\n---\n## REVIEWS\n#‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Oreilly-Stock-Trade-Example":{"title":"Oreilly Stock Trade Example","content":"# EXAMPLE\nFor example, a single event to place a stock trade might require you to first validate the trade, then check the compliance of that stock trade against various compliance rules, assign the trade to a broker, calculate the commission, and finally place the trade with that broker. All of these steps would require some level of orchestration to determine the order of the steps and which ones can be done serially and in parallel.\n\n---\n## REMINDS ME OF\n[[Layered Architecture]] because you have many layers of things that have to happen for a request to finish.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Performance-overhead":{"title":"Performance overhead","content":"# DEFINITION\nCoordinating and managing concurrency comes with an overhead cost. The additional complexity introduced by synchronization mechanisms, such as [[locks]] or [[semaphores]], can impact the overall performance of the system. Excessive synchronization or inefficient concurrency control mechanisms can degrade system performance.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Persistence-layer":{"title":"Persistence layer","content":"# DEFINITION\nThe persistence layer is responsible for saving and retrieving data, it sits after the [[Business layer]] and talks to an ORM or directly to a database in order to persist data. By using the persistence layer, we promote \u003cu\u003edecoupling\u003c/u\u003e and \u003cu\u003eflexibility\u003c/u\u003e, since we can always swap the database and only the persistence layer has to be changed.\n\n---\n## REVIEWS\n#‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Plugins":{"title":"Plugins","content":"\n# MY DEFINITION\n\nAdditional application features as plug-ins to the core application. They add functionality to the application.\n\n---\n## DEFINITION BY OREILLY\n\nThe plug-in modules are stand-alone, independent components that contain specialized processing, additional features, and custom code that is meant to enhance or extend the core system to produce additional business capabilities.\n\n---\n# EXTRA\n\nthere are situations where it makes sense to create an [[Adapter]] to make sure the [[Contract]] between the plugin and the contract your API knows how to deal with understand each other.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Point-to-point":{"title":"Point-to-point","content":"# DEFINITION\nConnects individual pairs of machines.\n\n---\n## HOW DOES IT WORK?\nshort messages called [[Packets]] are sent from one computer to another until it reaches the destination. \n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Presentation-layer":{"title":"Presentation layer","content":"# DEFINITION\nthe presentation layer is responsible for capturing requests and delivering responses to a client, usually in a nice front-end interface.\n\n---\n## RESPONSIBILITIES\n- User interface management.\n- Input validation.\n- User interaction.\n- Data presentation and formatting.\n- Security and access control.\n- Error handling and reporting.\n\n---\n## REVIEWS\n#‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Processes":{"title":"Processes","content":"","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Processing-Event":{"title":"Processing Event","content":"# DEFINITION\nthe processing event is the event the is being processed by the [[Event Processors]].\n\n---\n## REVIEWS\n#‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê \n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Processing-Grid":{"title":"Processing Grid","content":"# DEFINITION\n\nis an **optional component** within the virtualized middleware that manages distributed request processing when there are multiple processing units, each handling a portion of the application.\n\n---\n\n## EXAMPLE IMAGE\n\n![[Processing-grid component.png]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Processing-Unit":{"title":"Processing Unit","content":"\n# DEFINITION\n\nThe processing-unit component contains the application components (or portions of the application components). This includes web-based components as well as backend business logic. The unit also contains an in-memory [[Data Grid]].\n\n---\n## HOW-TO\nThe contents varies on the type of app, smaller apps might have a single processing unit, whereas larger apps might divide the functionality of the app into many processing units.\n\n---\n## EXAMPLE IMAGE\n![[Processing-unit component image.png]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Proxy":{"title":"Proxy","content":"# DEFINITION\nA proxy acts as a bridge between the client and the server. The proxy receives the requests and forwards it to the target server, retrieving the response that needs to be sent to the client.\n\n---\n## BENEFITS\n1. **Anonymity and Privacy**: Proxies can mask the client's IP address, making it difficult for the target server to identify the actual source of the request. This feature is often used to enhance privacy and maintain anonymity while browsing the internet.\n\n2. **Content Filtering**: Proxies can be configured to filter or block certain types of content, allowing organizations to control and monitor the resources accessed by their network users. This feature is commonly employed in workplaces, schools, and public networks to enforce internet usage policies.\n\n3. **Caching**: Proxies can cache frequently accessed resources locally, storing a copy of the requested content. When subsequent requests for the same resource are made, the proxy can serve the cached version instead of retrieving it from the target server. Caching improves response times and reduces bandwidth usage.\n\n4. **Load Balancing**: Proxies can distribute incoming client requests across multiple servers to balance the load and ensure efficient resource utilization. This approach helps enhance the performance, scalability, and availability of the target servers.\n\n5. **Security**: Proxies can act as a barrier between the client and the target server, providing an additional layer of security. They can filter out malicious traffic, block certain types of attacks, and provide SSL encryption to protect sensitive data transmitted between the client and the server.\n\n---\n## REVIEWS\n#‚≠ê ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Pub-Sub-Pattern":{"title":"Pub-Sub Pattern","content":"# DEFINITION\nThis pattern works much like the [[Observer Pattern]], events are **published (pub)** by a service and other services can **subscribe (sub)** to the events that interest them. When an event is created, it is sent to all subscribers and then they perform their actions subsequently.\n\n---\n## WHAT IS THE TOPIC QUEUE?\nIn pub-sub systems, a topic represents a specific **category or subject of events**. Publishers generate events and assign them to specific topics, while subscribers express their interest in **receiving events from specific topics**.The [[Topic Queue]] acts as an intermediary between publishers and subscribers.\n\n---\n## EXAMPLE IMAGE\n![[Pub-sub pattern image.png]]\n\n---\n## REVIEWS\n#‚≠ê ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/REST":{"title":"REST","content":"# DEFINITION","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/RabbitMQ":{"title":"RabbitMQ","content":"# DEFINITION\n\nA robust and flexible messaging broker that implements the **Advanced Message Queuing Protocol (AMQP)**. RabbitMQ offers reliable message delivery, various messaging patterns, and support for multiple programming languages.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Race-conditions":{"title":"Race conditions","content":"# DEFINITION\nRace conditions occur when multiple threads or [[Processes|processes]] access shared resources or variables concurrently, leading to unpredictable and incorrect results. It happens when the execution order of these [[Thread|threads]] affects the final outcome.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Relay-Race-Example":{"title":"Relay Race Example","content":"# EXAMPLE\n\nIn a relay race, runners hold a baton and run for a certain distance, then hand off the baton to the next runner, and so on down the chain until the last runner crosses the finish line. In relay races, once a runner hands off the baton, she is done with the race. This is also true with the broker topology: once an event processor hands off the event, it is no longer involved with the processing of that specific event.\n\n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/S.O.L.I.D.":{"title":"S.O.L.I.D.","content":"# TO GET STARTED\nThese five software development principles are guidelines to follow when building software so that it is \u003cu\u003eeasier to scale and maintain\u003c/u\u003e.\n\n---\n## PRINCIPLES\n[[Single Responsibility]] \n[[Open-Closed]]\n[[Liskov Substitution]]\n[[Interface Segregation]]\n[[Dependency Inversion]]\n\n---\n## SOURCE\n[Source Article](https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898)\n\n---\n## REVIEWS\n#‚åõ ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Service-Components":{"title":"Service Components","content":"\n# DEFINITION\n\nA component is a piece of software that is responsible for dealing with a specific set of tasks that are usually related, like a CMS deals with content. Some service components deal with only one task and are more granular, whereas some components deal with more than one task.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Single-Responsibility":{"title":"Single Responsibility","content":"# DEFINITION\nA class should have a single responsibility.\n\n---\n## EXAMPLE IMAGE\n![[Single Responsibility Image.png]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Space-based-Architecture":{"title":"Space-based Architecture","content":"# DEFINITION\nThe pattern gets its name from [[tuple space]]. The pattern removes the central database to achieve almost infinite scalability, since the biggest issue when it comes to scalability is scaling the database.\n\n---\n## COMPONENTS\nThere are two main components in this [[Architecture Patterns|architecture pattern]], the [[Processing Unit]] and the [[Virtualized Middleware]]\n\n---\n## EXAMPLE IMAGE\n![[Space-based architecture pattern image.png]]\n\n---\n## CONSIDERATIONS\nThe space-based architecture pattern is a complex and expensive pattern to implement. It is a good architecture choice for smaller web-based applications with variable load (e.g., social media sites, bidding and auction sites). However, it is not well suited for traditional large-scale relational database applications with large amounts of operational data.\n\n---\n## THIRD-PARTY SOFTWARE\nFrom a product implementation perspective, you can implement many of the architecture components in this pattern through third-party products such as [[GemFire]], [[JavaSpaces]], [[GigaSpaces]], [[IBM Object Grid]], [[nCache]], and [[Oracle Coherence]]. Because the implementation of this pattern varies greatly in terms of cost and capabilities (particularly data replication times), as an architect, you should first establish what your specific goals and needs are before making any product selections.\n\n---\n## PATTERN ANALYSIS\n[[Architecture Patterns Analysis]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Spring-Integration":{"title":"Spring Integration","content":"# DEFINITION\n\nSpring Integration is a lightweight framework within the larger Spring ecosystem that enables the integration of disparate systems and applications in a [[Messaging Based Architecture]]. It provides a set of tools and abstractions for building robust and scalable enterprise integration solutions.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Starvation":{"title":"Starvation","content":"# DEFINITION\nStarvation happens when a process or thread is unable to acquire the necessary resources or execution time due to the dominance of other processes. This results in the affected process being delayed indefinitely or not making progress.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Talk-1":{"title":"Talk 1","content":"# COMMENTS\n\nStudy about [[Event Sourcing]]\n\n---\n## DATE\n25/05/2023\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Talk-2":{"title":"Talk 2","content":"# QUESTIONS\n**do you have any project where I could see what an event is?**\nnotifications service\nbuffer\n\n**what is the difference between an event-driven-architecture and a microservices architecture?**\nmicro-services is a philosophy.\n\npontos positivos e negativos dos microservicos:\ngranularidade √© um desafio.\n\nsharding -\u003e scalibilidade horizontal do banco.\n\nponto positivo =\u003e um up time alto.\n\n**Have you ever used a data grid? Why does it offer almost infinite scalability?**\n\n**Is it better to scale a service horizontally?**\n\n**Having multiple databases makes it easier for scaling?**\n\n**The author states that the most difficult thing to scale is the database, is it because all requests hit the same \"node\" or central database?**\n\n**Should I go deeper on the topic of architecture patterns?**\n- entender bem a fundo sobre redes.\n- ngrok open-source\n\naritm√©tica de ponteiros (rust consegue)\n\nhttps://roadmap.sh/software-architect\n\n---\n## COMMENTS\n\n---\n## KNOWLEDGE GAPS\n\n---\n## REVIEWS\n#‚åõ \n\n---\n## DATE\n12/06/2023","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Thread":{"title":"Thread","content":"","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Topic-Queue":{"title":"Topic Queue","content":"\n# DEFINITION\n\nThe topic queue acts as an **intermediary** between publishers and subscribers, ensuring that events are properly delivered to the interested parties.\n\n---\n\n## KEY CONCEPTS\n\n**Event Distribution**: The topic queue serves as a central hub for events of a particular topic. It acts as a [[buffer]] or storage where events are temporarily held until they can be delivered to the subscribers. This allows for decoupling between publishers and subscribers since publishers don't need to know the specific subscribers or how many of them exist.\n\n**Scalability and Load Balancing**: The topic queue can be designed to support multiple instances or partitions to handle high event throughput and distribute the load across different nodes. This enables [[Horizontal Scalability]], ensuring efficient handling of events even in large-scale systems with a high volume of publishers and subscribers.\n\n**Guaranteed Delivery**: The topic queue can provide reliability and durability by persisting events even if subscribers are temporarily offline or unable to process events. This guarantees that events won't be lost and can be delivered to subscribers when they come back online.\n\n**Filtering and Routing**: Topic queues often provide filtering capabilities, allowing subscribers to specify criteria for the types of events they are interested in. Subscribers can subscribe to specific topics or apply filters based on event attributes, ensuring they only receive relevant events.\n\n---\n\n## EXAMPLE IMAGE\n\n![[Pub-sub pattern image.png]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Transport-Layer":{"title":"Transport Layer","content":"# DEFINITION\nThe transport layer is responsible for receiving requests and delivering responses to clients.\n\n---\n## REVIEWS\n#‚≠ê \n","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Use-Case":{"title":"Use Case","content":"# DEFINITION\n\na use case is responsible for orchestrating other components in the domain layer to execute a task.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Vertical-Scalability":{"title":"Vertical Scalability","content":"\n# DEFINITION\nVertical scaling is about increasing the resources of an existing machine by increasing RAM, CPU, and so on.\n\n---\n## EXAMPLE IMAGE\n![[Vertical Scaling Image.png]]\n\n---\n## LINKS TO\n[[Horizontal Scalability]]\n\n---\n## REVIEWS\n#‚≠ê","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Virtualized-Middleware":{"title":"Virtualized Middleware","content":"# DEFINITION\n\nThe virtualized-middleware component handles housekeeping and communications. It contains components that control various aspects of data synchronization and request handling. Included in the virtualized middleware are the messaging grid, data grid, processing grid, and deployment manager. These components, which are described in detail in the next section, can be custom written or purchased as third-party products.\n\n---\n\n## INNER-COMPONENTS\n\n[[Messaging grid]]\n[[Data Grid]]\n[[Processing Grid]]\n[[Deployment Manager]]\n\n---\n\n## EXAMPLE IMAGE\n\n## ![[Virtualized Middleware.png]]\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/What-is-a-database-transaction":{"title":"What is a database transaction","content":"# DEFINITION\n\nDatabase transaction is a group of requests to the database that are performed together as a single one.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/Why-should-I-use-layered-architecture":{"title":"Why should I use layered architecture","content":"# Why should I use a [[layered architecture]]?\n\n- changes are isolated to specific components of the application since they deal with specific tasks, it makes it easier to maintain code and therefore cheaper.\n- Software development is hard, we need to make it easier by creating good patterns that work in most enterprise applications, and layered architecture is a good one.\n\n---\n## REVIEWS\n#‚åõ","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/locks":{"title":"locks","content":"","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/messaging-infrastructure":{"title":"messaging infrastructure","content":"","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]},"/private/legacy/tuple-space":{"title":"tuple space","content":"","lastmodified":"2023-06-15T12:22:17.423513587Z","tags":[]}}